---
title: 嵌入式实时系统中的优先级反转问题
date: 2008-03-26 15:06:15
img: '/medias/10.jpg'
categories:
- C++
---


## 嵌入式实时系统中的优先级反转问题

### 1 问题的提出

　　目前，市场上占有率比较高的商业RTOS有VxWorks/PSOS、QNX、 LynxOS、VRTX,、Windows CE等。这些为数众多的RTOS绝大多数都是多任务实时微内核的结构，采用的是基于优先级的可抢占式调度策略。系统为每一个任务分配一个优先权，调度程序保证当前运行的进程是优先权最高的进程。但是，有时候会出现一种比较奇怪的现象：由于多进程共享资源，具有最高优先权的进程被低优先级进程阻塞，反而使具有中优先级的进程先于高优先级的进程执行，导致系统的崩溃。这就是所谓的优先级反转（Priority Inversion）。

### 2 优先级反转

RTOS普遍具有2个特点：实时性和多任务。实时是指系统的响应时间必须在规定的时间内，超出这个时间限制将会使系统出现致命的错误；同时，实时性还要求对时间要求非常急迫的任务要先于对时间不是很紧急的任务执行。正是由于这2个原因，RTOS的进程调度普遍采用的是基于优先级的可抢占式PBP （Priority Based Preemptive）的调度策略。多任务是嵌入式系统的内在要求。如今的嵌入式系统普遍要求具有多任务并发执行的能力，因此RTOS中也必须提供多任务并发执行的支持。由于多任务并发，必然会导致多个任务共享资源。如有2个任务task1和task2并发执行，都需要向打印机输出结果。由于只有1台打印机，所以在某个时间段内只能有1个任务，如task1占有打印机并向打印机输出，而这时另一个任务task2处于等待状态。当task1输出完毕后， task2由等待转为就绪，当RTOS再次调度它时，方可占有打印机向打印机输出。试想如果不采取这种方式，不对打印机这种共享资源加以控制，而让 task1和task2同时向打印机输出，这时候打印机打印的结果谁也看不懂，是一堆乱七八糟的东西。因此，大多数的RTOS采用了一种称作信号量（semaphore）的机制来实现对共享资源的管理。任何一个想使用临界资源（如打印机等共享资源）的进程在进入临界区（如task1或task2中访问临界资源的代码）之前必须拥有使用临界资源的信号量，否则不可以执行临界区代码。假设系统中有3个任务，分别为task1、task2和task3。 task1的优先权高于task2，而task2的优先权高于task3。恰在此时task1和task2 因某种原因被阻塞，这时候系统调度task3执行。task3执行一段时间后，task1被唤醒。由于采取的是PBP的调度策略，因此task1抢占 task3的CPU, task1执行。task1执行一段时间后要进入临界区，但此时task3占有此临界资源的信号量。因此task1被阻塞，处于等待状态，等待task3 释放此信号量。经过这么一段时间后，task2此时此刻处于就绪状态。因此系统调度task2执行。如果task3在task2的执行期间一直没有能够被调度执行的话，那task1和task3将一直等到task2执行完后才能执行，task1更要等到task3释放它所把持的信号量才能执行；而这段时间完全有可能超出task1的Deadline，使得task1崩溃。当系统看到有高优先级的任务崩溃时候，系统认为此时有重大事故发生，为了挽救系统，看门狗电路起作用，系统可能被自动复位。从上面的分析可以看到，导致系统崩溃的原因是由于优先级高的任务task1要获取被低优先级任务task2占有的临界资源而被task2阻塞，而具有中优先级的任务task2抢占task3的CPU,从而导致task2先于task1执行。这时候系统便出现了优先级反转的情况，如图1所示。优先级反转示意图

### 3 优先级反转的解决方法

　　目前解决优先级反转有许多种方法。其中普遍使用的有2种方法：一种被称作优先级继承（priority inheritance）；另一种被称作优先级极限（priority ceilings）。

　　在优先级继承方案中，当高优先级任务在等待低优先级的任务占有的信号量时，让低优先级任务继承高优先级任务的优先级，即把低优先级任务的优先权提高到高优先级任务的优先级；当低优先级任务释放高优先级任务等待的信号量时，立即把其优先权降低到原来的优先权。采用这种方法可以有效地解决上面所述的优先权反转的问题。当高优先级任务task1想要进入临界区时，由于低优先级任务task3占有这个临界资源的信号量，导致task1被阻塞。这时候，系统把task3的优先权升到task1的优先权，此时优先权处于task1和task3之间的任务task2，即使处于就绪状态也不可以被调度执行，因为此时task3的优先权已经高于task2，所以task3此时被调度执行。当task3释放task1需要的信号量时，系统立即把task3的优先权降到原来的高度，来保证task1和task2正常有序执行。整个情况如图2所示。目前，有许多RTOS是采用这种方法来防止优先级反转的，如大家比较熟悉的业界有名的WindRiver公司的VXWORKS。

采用优先级继承消除优先级反转

在优先权极限方案中，系统把每一个临界资源与1个极限优先权相联系。这个极限优先权等于系统此时最高优先权加1。当1个任务进入临界区时，系统便把这个极限优先权传递给这个任务，使得这个任务的优先权最高；当这个任务退出临界区后，系统立即把它的优先权恢复正常，从而保证系统不会出现优先权反转的情况。如上例中，当task3进入临界区时，立即把它的优先权升高到极限优先权，保证task3此时能尽快退出临界区，进而释放其占有的信号量。当高优先级任务 task1执行的时候就不会出现其等待低优先级任务task3释放信号量而被阻塞的情况，从而保证不会出现上面所说的优先级反转。采用这种方案的另一个有利之处，是仅仅通过改变某个临界资源的优先级就可以使多个任务共享这个临界资源，如下所示。

void TaskA(void){

...

SetTaskPriority(RES_X_PRIO);

// 访问共享资源 X.

SetTaskPriority(TASK_A_PRIO);

...

}

　　以上就RTOS中优先级反转问题出现的原因以及解决方法进行了详细的说明。21世纪将是嵌入式系统的时代。从事嵌入式系统设计的人员深入了解RTOS的原理和内部潜在的问题，如优先级反转等，将有助于开发出更加可靠的产品。